// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// This file was generated automatically.
// Please do not modify content of this file directly.
// File generated by using template: "toplevel.rs.tpl"
// To regenerate this file follow OpenTitan topgen documentations.

#![allow(dead_code)]

//! This file contains enums and consts for use within the Rust codebase.
//!
//! These definitions are for information that depends on the top-specific chip
//! configuration, which includes:
//! - Device Memory Information (for Peripherals and Memory)
//! - PLIC Interrupt ID Names and Source Mappings
//! - Alert ID Names and Source Mappings
//! - Pinmux Pin/Select Names
//! - Power Manager Wakeups

use core::convert::TryFrom;

/// Peripheral base address for gpio in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_GPIO_BASE_ADDR: usize = 0x30000000;

/// Peripheral size for gpio in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_GPIO_BASE_ADDR and
/// `TOP_DARJEELING_GPIO_BASE_ADDR + TOP_DARJEELING_GPIO_SIZE_BYTES`.
pub const TOP_DARJEELING_GPIO_SIZE_BYTES: usize = 0x40;
/// Peripheral base address for rv_timer in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_RV_TIMER_BASE_ADDR: usize = 0x30100000;

/// Peripheral size for rv_timer in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_RV_TIMER_BASE_ADDR and
/// `TOP_DARJEELING_RV_TIMER_BASE_ADDR + TOP_DARJEELING_RV_TIMER_SIZE_BYTES`.
pub const TOP_DARJEELING_RV_TIMER_SIZE_BYTES: usize = 0x200;
/// Peripheral base address for alert_handler in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_ALERT_HANDLER_BASE_ADDR: usize = 0x30150000;

/// Peripheral size for alert_handler in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_ALERT_HANDLER_BASE_ADDR and
/// `TOP_DARJEELING_ALERT_HANDLER_BASE_ADDR + TOP_DARJEELING_ALERT_HANDLER_SIZE_BYTES`.
pub const TOP_DARJEELING_ALERT_HANDLER_SIZE_BYTES: usize = 0x800;
/// Peripheral base address for pwrmgr_aon in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_PWRMGR_AON_BASE_ADDR: usize = 0x30400000;

/// Peripheral size for pwrmgr_aon in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_PWRMGR_AON_BASE_ADDR and
/// `TOP_DARJEELING_PWRMGR_AON_BASE_ADDR + TOP_DARJEELING_PWRMGR_AON_SIZE_BYTES`.
pub const TOP_DARJEELING_PWRMGR_AON_SIZE_BYTES: usize = 0x80;
/// Peripheral base address for rstmgr_aon in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_RSTMGR_AON_BASE_ADDR: usize = 0x30410000;

/// Peripheral size for rstmgr_aon in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_RSTMGR_AON_BASE_ADDR and
/// `TOP_DARJEELING_RSTMGR_AON_BASE_ADDR + TOP_DARJEELING_RSTMGR_AON_SIZE_BYTES`.
pub const TOP_DARJEELING_RSTMGR_AON_SIZE_BYTES: usize = 0x80;
/// Peripheral base address for clkmgr_aon in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_CLKMGR_AON_BASE_ADDR: usize = 0x30420000;

/// Peripheral size for clkmgr_aon in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_CLKMGR_AON_BASE_ADDR and
/// `TOP_DARJEELING_CLKMGR_AON_BASE_ADDR + TOP_DARJEELING_CLKMGR_AON_SIZE_BYTES`.
pub const TOP_DARJEELING_CLKMGR_AON_SIZE_BYTES: usize = 0x80;
/// Peripheral base address for pinmux_aon in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_PINMUX_AON_BASE_ADDR: usize = 0x30460000;

/// Peripheral size for pinmux_aon in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_PINMUX_AON_BASE_ADDR and
/// `TOP_DARJEELING_PINMUX_AON_BASE_ADDR + TOP_DARJEELING_PINMUX_AON_SIZE_BYTES`.
pub const TOP_DARJEELING_PINMUX_AON_SIZE_BYTES: usize = 0x400;
/// Peripheral base address for aon_timer_aon in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_AON_TIMER_AON_BASE_ADDR: usize = 0x30470000;

/// Peripheral size for aon_timer_aon in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_AON_TIMER_AON_BASE_ADDR and
/// `TOP_DARJEELING_AON_TIMER_AON_BASE_ADDR + TOP_DARJEELING_AON_TIMER_AON_SIZE_BYTES`.
pub const TOP_DARJEELING_AON_TIMER_AON_SIZE_BYTES: usize = 0x40;
/// Peripheral base address for ast in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_AST_BASE_ADDR: usize = 0x30480000;

/// Peripheral size for ast in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_AST_BASE_ADDR and
/// `TOP_DARJEELING_AST_BASE_ADDR + TOP_DARJEELING_AST_SIZE_BYTES`.
pub const TOP_DARJEELING_AST_SIZE_BYTES: usize = 0x400;
/// Peripheral base address for regs device on sram_ctrl_ret_aon in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_SRAM_CTRL_RET_AON_REGS_BASE_ADDR: usize = 0x30500000;

/// Peripheral size for regs device on sram_ctrl_ret_aon in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_SRAM_CTRL_RET_AON_REGS_BASE_ADDR and
/// `TOP_DARJEELING_SRAM_CTRL_RET_AON_REGS_BASE_ADDR + TOP_DARJEELING_SRAM_CTRL_RET_AON_REGS_SIZE_BYTES`.
pub const TOP_DARJEELING_SRAM_CTRL_RET_AON_REGS_SIZE_BYTES: usize = 0x20;
/// Peripheral base address for ram device on sram_ctrl_ret_aon in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_SRAM_CTRL_RET_AON_RAM_BASE_ADDR: usize = 0x40600000;

/// Peripheral size for ram device on sram_ctrl_ret_aon in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_SRAM_CTRL_RET_AON_RAM_BASE_ADDR and
/// `TOP_DARJEELING_SRAM_CTRL_RET_AON_RAM_BASE_ADDR + TOP_DARJEELING_SRAM_CTRL_RET_AON_RAM_SIZE_BYTES`.
pub const TOP_DARJEELING_SRAM_CTRL_RET_AON_RAM_SIZE_BYTES: usize = 0x1000;
/// Peripheral base address for regs device on rv_dm in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_RV_DM_REGS_BASE_ADDR: usize = 0x21200000;

/// Peripheral size for regs device on rv_dm in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_RV_DM_REGS_BASE_ADDR and
/// `TOP_DARJEELING_RV_DM_REGS_BASE_ADDR + TOP_DARJEELING_RV_DM_REGS_SIZE_BYTES`.
pub const TOP_DARJEELING_RV_DM_REGS_SIZE_BYTES: usize = 0x4;
/// Peripheral base address for mem device on rv_dm in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_RV_DM_MEM_BASE_ADDR: usize = 0x40000;

/// Peripheral size for mem device on rv_dm in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_RV_DM_MEM_BASE_ADDR and
/// `TOP_DARJEELING_RV_DM_MEM_BASE_ADDR + TOP_DARJEELING_RV_DM_MEM_SIZE_BYTES`.
pub const TOP_DARJEELING_RV_DM_MEM_SIZE_BYTES: usize = 0x1000;
/// Peripheral base address for rv_plic in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_RV_PLIC_BASE_ADDR: usize = 0x28000000;

/// Peripheral size for rv_plic in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_RV_PLIC_BASE_ADDR and
/// `TOP_DARJEELING_RV_PLIC_BASE_ADDR + TOP_DARJEELING_RV_PLIC_SIZE_BYTES`.
pub const TOP_DARJEELING_RV_PLIC_SIZE_BYTES: usize = 0x8000000;
/// Peripheral base address for otbn in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_OTBN_BASE_ADDR: usize = 0x21130000;

/// Peripheral size for otbn in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_OTBN_BASE_ADDR and
/// `TOP_DARJEELING_OTBN_BASE_ADDR + TOP_DARJEELING_OTBN_SIZE_BYTES`.
pub const TOP_DARJEELING_OTBN_SIZE_BYTES: usize = 0x10000;
/// Peripheral base address for regs device on sram_ctrl_main in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_SRAM_CTRL_MAIN_REGS_BASE_ADDR: usize = 0x211C0000;

/// Peripheral size for regs device on sram_ctrl_main in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_SRAM_CTRL_MAIN_REGS_BASE_ADDR and
/// `TOP_DARJEELING_SRAM_CTRL_MAIN_REGS_BASE_ADDR + TOP_DARJEELING_SRAM_CTRL_MAIN_REGS_SIZE_BYTES`.
pub const TOP_DARJEELING_SRAM_CTRL_MAIN_REGS_SIZE_BYTES: usize = 0x20;
/// Peripheral base address for ram device on sram_ctrl_main in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_SRAM_CTRL_MAIN_RAM_BASE_ADDR: usize = 0x10000000;

/// Peripheral size for ram device on sram_ctrl_main in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_SRAM_CTRL_MAIN_RAM_BASE_ADDR and
/// `TOP_DARJEELING_SRAM_CTRL_MAIN_RAM_BASE_ADDR + TOP_DARJEELING_SRAM_CTRL_MAIN_RAM_SIZE_BYTES`.
pub const TOP_DARJEELING_SRAM_CTRL_MAIN_RAM_SIZE_BYTES: usize = 0x10000;
/// Peripheral base address for regs device on sram_ctrl_mbox in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_SRAM_CTRL_MBOX_REGS_BASE_ADDR: usize = 0x211D0000;

/// Peripheral size for regs device on sram_ctrl_mbox in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_SRAM_CTRL_MBOX_REGS_BASE_ADDR and
/// `TOP_DARJEELING_SRAM_CTRL_MBOX_REGS_BASE_ADDR + TOP_DARJEELING_SRAM_CTRL_MBOX_REGS_SIZE_BYTES`.
pub const TOP_DARJEELING_SRAM_CTRL_MBOX_REGS_SIZE_BYTES: usize = 0x20;
/// Peripheral base address for ram device on sram_ctrl_mbox in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_SRAM_CTRL_MBOX_RAM_BASE_ADDR: usize = 0x11000000;

/// Peripheral size for ram device on sram_ctrl_mbox in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_SRAM_CTRL_MBOX_RAM_BASE_ADDR and
/// `TOP_DARJEELING_SRAM_CTRL_MBOX_RAM_BASE_ADDR + TOP_DARJEELING_SRAM_CTRL_MBOX_RAM_SIZE_BYTES`.
pub const TOP_DARJEELING_SRAM_CTRL_MBOX_RAM_SIZE_BYTES: usize = 0x1000;
/// Peripheral base address for cfg device on rv_core_ibex in top darjeeling.
///
/// This should be used with #mmio_region_from_addr to access the memory-mapped
/// registers associated with the peripheral (usually via a DIF).
pub const TOP_DARJEELING_RV_CORE_IBEX_CFG_BASE_ADDR: usize = 0x211F0000;

/// Peripheral size for cfg device on rv_core_ibex in top darjeeling.
///
/// This is the size (in bytes) of the peripheral's reserved memory area. All
/// memory-mapped registers associated with this peripheral should have an
/// address between #TOP_DARJEELING_RV_CORE_IBEX_CFG_BASE_ADDR and
/// `TOP_DARJEELING_RV_CORE_IBEX_CFG_BASE_ADDR + TOP_DARJEELING_RV_CORE_IBEX_CFG_SIZE_BYTES`.
pub const TOP_DARJEELING_RV_CORE_IBEX_CFG_SIZE_BYTES: usize = 0x800;

/// Memory base address for ram_ret_aon in top darjeeling.
pub const RAM_RET_AON_BASE_ADDR: usize = 0x40600000;

/// Memory size for ram_ret_aon in top darjeeling.
pub const RAM_RET_AON_SIZE_BYTES: usize = 0x1000;
/// Memory base address for ram_main in top darjeeling.
pub const RAM_MAIN_BASE_ADDR: usize = 0x10000000;

/// Memory size for ram_main in top darjeeling.
pub const RAM_MAIN_SIZE_BYTES: usize = 0x10000;
/// Memory base address for ram_mbox in top darjeeling.
pub const RAM_MBOX_BASE_ADDR: usize = 0x11000000;

/// Memory size for ram_mbox in top darjeeling.
pub const RAM_MBOX_SIZE_BYTES: usize = 0x1000;

/// PLIC Interrupt Source Peripheral.
///
/// Enumeration used to determine which peripheral asserted the corresponding
/// interrupt.
#[repr(u32)]
pub enum TopDarjeelingPlicPeripheral {
    /// Unknown Peripheral
    Unknown = 0,
    /// gpio
    Gpio = 1,
    /// rv_timer
    RvTimer = 2,
    /// alert_handler
    AlertHandler = 3,
    /// pwrmgr_aon
    PwrmgrAon = 4,
    /// aon_timer_aon
    AonTimerAon = 5,
    /// otbn
    Otbn = 6,
}

impl TryFrom<u32> for TopDarjeelingPlicPeripheral {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::Unknown),
            1 => Ok(Self::Gpio),
            2 => Ok(Self::RvTimer),
            3 => Ok(Self::AlertHandler),
            4 => Ok(Self::PwrmgrAon),
            5 => Ok(Self::AonTimerAon),
            6 => Ok(Self::Otbn),
            _ => Err(val),
        }
    }
}

/// PLIC Interrupt Source.
///
/// Enumeration of all PLIC interrupt sources. The interrupt sources belonging to
/// the same peripheral are guaranteed to be consecutive.
#[repr(u32)]
pub enum TopDarjeelingPlicIrqId {
    /// No Interrupt
    None = 0,
    /// gpio_gpio 0
    GpioGpio0 = 1,
    /// gpio_gpio 1
    GpioGpio1 = 2,
    /// gpio_gpio 2
    GpioGpio2 = 3,
    /// gpio_gpio 3
    GpioGpio3 = 4,
    /// gpio_gpio 4
    GpioGpio4 = 5,
    /// gpio_gpio 5
    GpioGpio5 = 6,
    /// gpio_gpio 6
    GpioGpio6 = 7,
    /// gpio_gpio 7
    GpioGpio7 = 8,
    /// gpio_gpio 8
    GpioGpio8 = 9,
    /// gpio_gpio 9
    GpioGpio9 = 10,
    /// gpio_gpio 10
    GpioGpio10 = 11,
    /// gpio_gpio 11
    GpioGpio11 = 12,
    /// gpio_gpio 12
    GpioGpio12 = 13,
    /// gpio_gpio 13
    GpioGpio13 = 14,
    /// gpio_gpio 14
    GpioGpio14 = 15,
    /// gpio_gpio 15
    GpioGpio15 = 16,
    /// gpio_gpio 16
    GpioGpio16 = 17,
    /// gpio_gpio 17
    GpioGpio17 = 18,
    /// gpio_gpio 18
    GpioGpio18 = 19,
    /// gpio_gpio 19
    GpioGpio19 = 20,
    /// gpio_gpio 20
    GpioGpio20 = 21,
    /// gpio_gpio 21
    GpioGpio21 = 22,
    /// gpio_gpio 22
    GpioGpio22 = 23,
    /// gpio_gpio 23
    GpioGpio23 = 24,
    /// gpio_gpio 24
    GpioGpio24 = 25,
    /// gpio_gpio 25
    GpioGpio25 = 26,
    /// gpio_gpio 26
    GpioGpio26 = 27,
    /// gpio_gpio 27
    GpioGpio27 = 28,
    /// gpio_gpio 28
    GpioGpio28 = 29,
    /// gpio_gpio 29
    GpioGpio29 = 30,
    /// gpio_gpio 30
    GpioGpio30 = 31,
    /// gpio_gpio 31
    GpioGpio31 = 32,
    /// rv_timer_timer_expired_hart0_timer0
    RvTimerTimerExpiredHart0Timer0 = 33,
    /// alert_handler_classa
    AlertHandlerClassa = 34,
    /// alert_handler_classb
    AlertHandlerClassb = 35,
    /// alert_handler_classc
    AlertHandlerClassc = 36,
    /// alert_handler_classd
    AlertHandlerClassd = 37,
    /// pwrmgr_aon_wakeup
    PwrmgrAonWakeup = 38,
    /// aon_timer_aon_wkup_timer_expired
    AonTimerAonWkupTimerExpired = 39,
    /// aon_timer_aon_wdog_timer_bark
    AonTimerAonWdogTimerBark = 40,
    /// otbn_done
    OtbnDone = 41,
}

impl TryFrom<u32> for TopDarjeelingPlicIrqId {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::None),
            1 => Ok(Self::GpioGpio0),
            2 => Ok(Self::GpioGpio1),
            3 => Ok(Self::GpioGpio2),
            4 => Ok(Self::GpioGpio3),
            5 => Ok(Self::GpioGpio4),
            6 => Ok(Self::GpioGpio5),
            7 => Ok(Self::GpioGpio6),
            8 => Ok(Self::GpioGpio7),
            9 => Ok(Self::GpioGpio8),
            10 => Ok(Self::GpioGpio9),
            11 => Ok(Self::GpioGpio10),
            12 => Ok(Self::GpioGpio11),
            13 => Ok(Self::GpioGpio12),
            14 => Ok(Self::GpioGpio13),
            15 => Ok(Self::GpioGpio14),
            16 => Ok(Self::GpioGpio15),
            17 => Ok(Self::GpioGpio16),
            18 => Ok(Self::GpioGpio17),
            19 => Ok(Self::GpioGpio18),
            20 => Ok(Self::GpioGpio19),
            21 => Ok(Self::GpioGpio20),
            22 => Ok(Self::GpioGpio21),
            23 => Ok(Self::GpioGpio22),
            24 => Ok(Self::GpioGpio23),
            25 => Ok(Self::GpioGpio24),
            26 => Ok(Self::GpioGpio25),
            27 => Ok(Self::GpioGpio26),
            28 => Ok(Self::GpioGpio27),
            29 => Ok(Self::GpioGpio28),
            30 => Ok(Self::GpioGpio29),
            31 => Ok(Self::GpioGpio30),
            32 => Ok(Self::GpioGpio31),
            33 => Ok(Self::RvTimerTimerExpiredHart0Timer0),
            34 => Ok(Self::AlertHandlerClassa),
            35 => Ok(Self::AlertHandlerClassb),
            36 => Ok(Self::AlertHandlerClassc),
            37 => Ok(Self::AlertHandlerClassd),
            38 => Ok(Self::PwrmgrAonWakeup),
            39 => Ok(Self::AonTimerAonWkupTimerExpired),
            40 => Ok(Self::AonTimerAonWdogTimerBark),
            41 => Ok(Self::OtbnDone),
            _ => Err(val),
        }
    }
}

/// PLIC Interrupt Target.
///
/// Enumeration used to determine which set of IE, CC, threshold registers to
/// access for a given interrupt target.
#[repr(u32)]
pub enum TopDarjeelingPlicTarget {
    /// Ibex Core 0
    Ibex0 = 0,
}

/// Alert Handler Source Peripheral.
///
/// Enumeration used to determine which peripheral asserted the corresponding
/// alert.
#[repr(u32)]
pub enum TopDarjeelingAlertPeripheral {
    /// gpio
    Gpio = 0,
    /// rv_timer
    RvTimer = 1,
    /// pwrmgr_aon
    PwrmgrAon = 2,
    /// rstmgr_aon
    RstmgrAon = 3,
    /// clkmgr_aon
    ClkmgrAon = 4,
    /// pinmux_aon
    PinmuxAon = 5,
    /// aon_timer_aon
    AonTimerAon = 6,
    /// sram_ctrl_ret_aon
    SramCtrlRetAon = 7,
    /// rv_dm
    RvDm = 8,
    /// rv_plic
    RvPlic = 9,
    /// otbn
    Otbn = 10,
    /// sram_ctrl_main
    SramCtrlMain = 11,
    /// sram_ctrl_mbox
    SramCtrlMbox = 12,
    /// rv_core_ibex
    RvCoreIbex = 13,
}

/// Alert Handler Alert Source.
///
/// Enumeration of all Alert Handler Alert Sources. The alert sources belonging to
/// the same peripheral are guaranteed to be consecutive.
#[repr(u32)]
pub enum TopDarjeelingAlertId {
    /// gpio_fatal_fault
    GpioFatalFault = 0,
    /// rv_timer_fatal_fault
    RvTimerFatalFault = 1,
    /// pwrmgr_aon_fatal_fault
    PwrmgrAonFatalFault = 2,
    /// rstmgr_aon_fatal_fault
    RstmgrAonFatalFault = 3,
    /// rstmgr_aon_fatal_cnsty_fault
    RstmgrAonFatalCnstyFault = 4,
    /// clkmgr_aon_recov_fault
    ClkmgrAonRecovFault = 5,
    /// clkmgr_aon_fatal_fault
    ClkmgrAonFatalFault = 6,
    /// pinmux_aon_fatal_fault
    PinmuxAonFatalFault = 7,
    /// aon_timer_aon_fatal_fault
    AonTimerAonFatalFault = 8,
    /// sram_ctrl_ret_aon_fatal_error
    SramCtrlRetAonFatalError = 9,
    /// rv_dm_fatal_fault
    RvDmFatalFault = 10,
    /// rv_plic_fatal_fault
    RvPlicFatalFault = 11,
    /// otbn_fatal
    OtbnFatal = 12,
    /// otbn_recov
    OtbnRecov = 13,
    /// sram_ctrl_main_fatal_error
    SramCtrlMainFatalError = 14,
    /// sram_ctrl_mbox_fatal_error
    SramCtrlMboxFatalError = 15,
    /// rv_core_ibex_fatal_sw_err
    RvCoreIbexFatalSwErr = 16,
    /// rv_core_ibex_recov_sw_err
    RvCoreIbexRecovSwErr = 17,
    /// rv_core_ibex_fatal_hw_err
    RvCoreIbexFatalHwErr = 18,
    /// rv_core_ibex_recov_hw_err
    RvCoreIbexRecovHwErr = 19,
}

impl TryFrom<u32> for TopDarjeelingAlertId {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::GpioFatalFault),
            1 => Ok(Self::RvTimerFatalFault),
            2 => Ok(Self::PwrmgrAonFatalFault),
            3 => Ok(Self::RstmgrAonFatalFault),
            4 => Ok(Self::RstmgrAonFatalCnstyFault),
            5 => Ok(Self::ClkmgrAonRecovFault),
            6 => Ok(Self::ClkmgrAonFatalFault),
            7 => Ok(Self::PinmuxAonFatalFault),
            8 => Ok(Self::AonTimerAonFatalFault),
            9 => Ok(Self::SramCtrlRetAonFatalError),
            10 => Ok(Self::RvDmFatalFault),
            11 => Ok(Self::RvPlicFatalFault),
            12 => Ok(Self::OtbnFatal),
            13 => Ok(Self::OtbnRecov),
            14 => Ok(Self::SramCtrlMainFatalError),
            15 => Ok(Self::SramCtrlMboxFatalError),
            16 => Ok(Self::RvCoreIbexFatalSwErr),
            17 => Ok(Self::RvCoreIbexRecovSwErr),
            18 => Ok(Self::RvCoreIbexFatalHwErr),
            19 => Ok(Self::RvCoreIbexRecovHwErr),
            _ => Err(val),
        }
    }
}

/// PLIC Interrupt Source to Peripheral Map
///
/// This array is a mapping from `TopDarjeelingPlicIrqId` to
/// `TopDarjeelingPlicPeripheral`.
pub const TOP_DARJEELING_PLIC_INTERRUPT_FOR_PERIPHERAL: [TopDarjeelingPlicPeripheral; 42] = [
    // None -> TopDarjeelingPlicPeripheral::Unknown
    TopDarjeelingPlicPeripheral::Unknown,
    // GpioGpio0 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio1 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio2 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio3 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio4 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio5 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio6 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio7 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio8 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio9 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio10 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio11 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio12 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio13 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio14 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio15 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio16 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio17 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio18 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio19 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio20 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio21 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio22 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio23 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio24 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio25 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio26 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio27 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio28 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio29 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio30 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // GpioGpio31 -> TopDarjeelingPlicPeripheral::Gpio
    TopDarjeelingPlicPeripheral::Gpio,
    // RvTimerTimerExpiredHart0Timer0 -> TopDarjeelingPlicPeripheral::RvTimer
    TopDarjeelingPlicPeripheral::RvTimer,
    // AlertHandlerClassa -> TopDarjeelingPlicPeripheral::AlertHandler
    TopDarjeelingPlicPeripheral::AlertHandler,
    // AlertHandlerClassb -> TopDarjeelingPlicPeripheral::AlertHandler
    TopDarjeelingPlicPeripheral::AlertHandler,
    // AlertHandlerClassc -> TopDarjeelingPlicPeripheral::AlertHandler
    TopDarjeelingPlicPeripheral::AlertHandler,
    // AlertHandlerClassd -> TopDarjeelingPlicPeripheral::AlertHandler
    TopDarjeelingPlicPeripheral::AlertHandler,
    // PwrmgrAonWakeup -> TopDarjeelingPlicPeripheral::PwrmgrAon
    TopDarjeelingPlicPeripheral::PwrmgrAon,
    // AonTimerAonWkupTimerExpired -> TopDarjeelingPlicPeripheral::AonTimerAon
    TopDarjeelingPlicPeripheral::AonTimerAon,
    // AonTimerAonWdogTimerBark -> TopDarjeelingPlicPeripheral::AonTimerAon
    TopDarjeelingPlicPeripheral::AonTimerAon,
    // OtbnDone -> TopDarjeelingPlicPeripheral::Otbn
    TopDarjeelingPlicPeripheral::Otbn,
];

/// Alert Handler Alert Source to Peripheral Map
///
/// This array is a mapping from `TopDarjeelingAlertId` to
/// `TopDarjeelingAlertPeripheral`.
pub const TOP_DARJEELING_ALERT_FOR_PERIPHERAL: [TopDarjeelingAlertPeripheral; 20] = [
    // GpioFatalFault -> TopDarjeelingAlertPeripheral::Gpio
    TopDarjeelingAlertPeripheral::Gpio,
    // RvTimerFatalFault -> TopDarjeelingAlertPeripheral::RvTimer
    TopDarjeelingAlertPeripheral::RvTimer,
    // PwrmgrAonFatalFault -> TopDarjeelingAlertPeripheral::PwrmgrAon
    TopDarjeelingAlertPeripheral::PwrmgrAon,
    // RstmgrAonFatalFault -> TopDarjeelingAlertPeripheral::RstmgrAon
    TopDarjeelingAlertPeripheral::RstmgrAon,
    // RstmgrAonFatalCnstyFault -> TopDarjeelingAlertPeripheral::RstmgrAon
    TopDarjeelingAlertPeripheral::RstmgrAon,
    // ClkmgrAonRecovFault -> TopDarjeelingAlertPeripheral::ClkmgrAon
    TopDarjeelingAlertPeripheral::ClkmgrAon,
    // ClkmgrAonFatalFault -> TopDarjeelingAlertPeripheral::ClkmgrAon
    TopDarjeelingAlertPeripheral::ClkmgrAon,
    // PinmuxAonFatalFault -> TopDarjeelingAlertPeripheral::PinmuxAon
    TopDarjeelingAlertPeripheral::PinmuxAon,
    // AonTimerAonFatalFault -> TopDarjeelingAlertPeripheral::AonTimerAon
    TopDarjeelingAlertPeripheral::AonTimerAon,
    // SramCtrlRetAonFatalError -> TopDarjeelingAlertPeripheral::SramCtrlRetAon
    TopDarjeelingAlertPeripheral::SramCtrlRetAon,
    // RvDmFatalFault -> TopDarjeelingAlertPeripheral::RvDm
    TopDarjeelingAlertPeripheral::RvDm,
    // RvPlicFatalFault -> TopDarjeelingAlertPeripheral::RvPlic
    TopDarjeelingAlertPeripheral::RvPlic,
    // OtbnFatal -> TopDarjeelingAlertPeripheral::Otbn
    TopDarjeelingAlertPeripheral::Otbn,
    // OtbnRecov -> TopDarjeelingAlertPeripheral::Otbn
    TopDarjeelingAlertPeripheral::Otbn,
    // SramCtrlMainFatalError -> TopDarjeelingAlertPeripheral::SramCtrlMain
    TopDarjeelingAlertPeripheral::SramCtrlMain,
    // SramCtrlMboxFatalError -> TopDarjeelingAlertPeripheral::SramCtrlMbox
    TopDarjeelingAlertPeripheral::SramCtrlMbox,
    // RvCoreIbexFatalSwErr -> TopDarjeelingAlertPeripheral::RvCoreIbex
    TopDarjeelingAlertPeripheral::RvCoreIbex,
    // RvCoreIbexRecovSwErr -> TopDarjeelingAlertPeripheral::RvCoreIbex
    TopDarjeelingAlertPeripheral::RvCoreIbex,
    // RvCoreIbexFatalHwErr -> TopDarjeelingAlertPeripheral::RvCoreIbex
    TopDarjeelingAlertPeripheral::RvCoreIbex,
    // RvCoreIbexRecovHwErr -> TopDarjeelingAlertPeripheral::RvCoreIbex
    TopDarjeelingAlertPeripheral::RvCoreIbex,
];

// PERIPH_INSEL ranges from 0 to TOP_DARJEELING_NUM_MIO_PADS + 2 -1}
//  0 and 1 are tied to value 0 and 1
pub const TOP_DARJEELING_NUM_MIO_PADS: usize = 1;
pub const TOP_DARJEELING_NUM_DIO_PADS: usize = 0;

pub const TOP_DARJEELING_PINMUX_MIO_PERIPH_INSEL_IDX_OFFSET: usize = 2;
pub const TOP_DARJEELING_PINMUX_PERIPH_OUTSEL_IDX_OFFSET: usize = 3;

/// Pinmux Peripheral Input.
#[repr(u32)]
pub enum TopDarjeelingPinmuxPeripheralIn {
    /// Peripheral Input 0
    GpioGpio0 = 0,
    /// Peripheral Input 1
    GpioGpio1 = 1,
    /// Peripheral Input 2
    GpioGpio2 = 2,
    /// Peripheral Input 3
    GpioGpio3 = 3,
    /// Peripheral Input 4
    GpioGpio4 = 4,
    /// Peripheral Input 5
    GpioGpio5 = 5,
    /// Peripheral Input 6
    GpioGpio6 = 6,
    /// Peripheral Input 7
    GpioGpio7 = 7,
    /// Peripheral Input 8
    GpioGpio8 = 8,
    /// Peripheral Input 9
    GpioGpio9 = 9,
    /// Peripheral Input 10
    GpioGpio10 = 10,
    /// Peripheral Input 11
    GpioGpio11 = 11,
    /// Peripheral Input 12
    GpioGpio12 = 12,
    /// Peripheral Input 13
    GpioGpio13 = 13,
    /// Peripheral Input 14
    GpioGpio14 = 14,
    /// Peripheral Input 15
    GpioGpio15 = 15,
    /// Peripheral Input 16
    GpioGpio16 = 16,
    /// Peripheral Input 17
    GpioGpio17 = 17,
    /// Peripheral Input 18
    GpioGpio18 = 18,
    /// Peripheral Input 19
    GpioGpio19 = 19,
    /// Peripheral Input 20
    GpioGpio20 = 20,
    /// Peripheral Input 21
    GpioGpio21 = 21,
    /// Peripheral Input 22
    GpioGpio22 = 22,
    /// Peripheral Input 23
    GpioGpio23 = 23,
    /// Peripheral Input 24
    GpioGpio24 = 24,
    /// Peripheral Input 25
    GpioGpio25 = 25,
    /// Peripheral Input 26
    GpioGpio26 = 26,
    /// Peripheral Input 27
    GpioGpio27 = 27,
    /// Peripheral Input 28
    GpioGpio28 = 28,
    /// Peripheral Input 29
    GpioGpio29 = 29,
    /// Peripheral Input 30
    GpioGpio30 = 30,
    /// Peripheral Input 31
    GpioGpio31 = 31,
}

impl TryFrom<u32> for TopDarjeelingPinmuxPeripheralIn {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::GpioGpio0),
            1 => Ok(Self::GpioGpio1),
            2 => Ok(Self::GpioGpio2),
            3 => Ok(Self::GpioGpio3),
            4 => Ok(Self::GpioGpio4),
            5 => Ok(Self::GpioGpio5),
            6 => Ok(Self::GpioGpio6),
            7 => Ok(Self::GpioGpio7),
            8 => Ok(Self::GpioGpio8),
            9 => Ok(Self::GpioGpio9),
            10 => Ok(Self::GpioGpio10),
            11 => Ok(Self::GpioGpio11),
            12 => Ok(Self::GpioGpio12),
            13 => Ok(Self::GpioGpio13),
            14 => Ok(Self::GpioGpio14),
            15 => Ok(Self::GpioGpio15),
            16 => Ok(Self::GpioGpio16),
            17 => Ok(Self::GpioGpio17),
            18 => Ok(Self::GpioGpio18),
            19 => Ok(Self::GpioGpio19),
            20 => Ok(Self::GpioGpio20),
            21 => Ok(Self::GpioGpio21),
            22 => Ok(Self::GpioGpio22),
            23 => Ok(Self::GpioGpio23),
            24 => Ok(Self::GpioGpio24),
            25 => Ok(Self::GpioGpio25),
            26 => Ok(Self::GpioGpio26),
            27 => Ok(Self::GpioGpio27),
            28 => Ok(Self::GpioGpio28),
            29 => Ok(Self::GpioGpio29),
            30 => Ok(Self::GpioGpio30),
            31 => Ok(Self::GpioGpio31),
            _ => Err(val),
        }
    }
}

/// Pinmux MIO Input Selector.
#[repr(u32)]
pub enum TopDarjeelingPinmuxInsel {
    /// Tie constantly to zero
    ConstantZero = 0,
    /// Tie constantly to one
    ConstantOne = 1,
    /// MIO Pad 0
    Ddr_pcamp = 2,
}

impl TryFrom<u32> for TopDarjeelingPinmuxInsel {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::ConstantZero),
            1 => Ok(Self::ConstantOne),
            2 => Ok(Self::Ddr_pcamp),
            _ => Err(val),
        }
    }
}

/// Pinmux MIO Output.
#[repr(u32)]
pub enum TopDarjeelingPinmuxMioOut {
    /// MIO Pad 0
    DdrPcamp = 0,
}

impl TryFrom<u32> for TopDarjeelingPinmuxMioOut {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::DdrPcamp),
            _ => Err(val),
        }
    }
}

/// Pinmux Peripheral Output Selector.
#[repr(u32)]
pub enum TopDarjeelingPinmuxOutsel {
    /// Tie constantly to zero
    ConstantZero = 0,
    /// Tie constantly to one
    ConstantOne = 1,
    /// Tie constantly to high-Z
    ConstantHighZ = 2,
    /// Peripheral Output 0
    GpioGpio0 = 3,
    /// Peripheral Output 1
    GpioGpio1 = 4,
    /// Peripheral Output 2
    GpioGpio2 = 5,
    /// Peripheral Output 3
    GpioGpio3 = 6,
    /// Peripheral Output 4
    GpioGpio4 = 7,
    /// Peripheral Output 5
    GpioGpio5 = 8,
    /// Peripheral Output 6
    GpioGpio6 = 9,
    /// Peripheral Output 7
    GpioGpio7 = 10,
    /// Peripheral Output 8
    GpioGpio8 = 11,
    /// Peripheral Output 9
    GpioGpio9 = 12,
    /// Peripheral Output 10
    GpioGpio10 = 13,
    /// Peripheral Output 11
    GpioGpio11 = 14,
    /// Peripheral Output 12
    GpioGpio12 = 15,
    /// Peripheral Output 13
    GpioGpio13 = 16,
    /// Peripheral Output 14
    GpioGpio14 = 17,
    /// Peripheral Output 15
    GpioGpio15 = 18,
    /// Peripheral Output 16
    GpioGpio16 = 19,
    /// Peripheral Output 17
    GpioGpio17 = 20,
    /// Peripheral Output 18
    GpioGpio18 = 21,
    /// Peripheral Output 19
    GpioGpio19 = 22,
    /// Peripheral Output 20
    GpioGpio20 = 23,
    /// Peripheral Output 21
    GpioGpio21 = 24,
    /// Peripheral Output 22
    GpioGpio22 = 25,
    /// Peripheral Output 23
    GpioGpio23 = 26,
    /// Peripheral Output 24
    GpioGpio24 = 27,
    /// Peripheral Output 25
    GpioGpio25 = 28,
    /// Peripheral Output 26
    GpioGpio26 = 29,
    /// Peripheral Output 27
    GpioGpio27 = 30,
    /// Peripheral Output 28
    GpioGpio28 = 31,
    /// Peripheral Output 29
    GpioGpio29 = 32,
    /// Peripheral Output 30
    GpioGpio30 = 33,
    /// Peripheral Output 31
    GpioGpio31 = 34,
}

impl TryFrom<u32> for TopDarjeelingPinmuxOutsel {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::ConstantZero),
            1 => Ok(Self::ConstantOne),
            2 => Ok(Self::ConstantHighZ),
            3 => Ok(Self::GpioGpio0),
            4 => Ok(Self::GpioGpio1),
            5 => Ok(Self::GpioGpio2),
            6 => Ok(Self::GpioGpio3),
            7 => Ok(Self::GpioGpio4),
            8 => Ok(Self::GpioGpio5),
            9 => Ok(Self::GpioGpio6),
            10 => Ok(Self::GpioGpio7),
            11 => Ok(Self::GpioGpio8),
            12 => Ok(Self::GpioGpio9),
            13 => Ok(Self::GpioGpio10),
            14 => Ok(Self::GpioGpio11),
            15 => Ok(Self::GpioGpio12),
            16 => Ok(Self::GpioGpio13),
            17 => Ok(Self::GpioGpio14),
            18 => Ok(Self::GpioGpio15),
            19 => Ok(Self::GpioGpio16),
            20 => Ok(Self::GpioGpio17),
            21 => Ok(Self::GpioGpio18),
            22 => Ok(Self::GpioGpio19),
            23 => Ok(Self::GpioGpio20),
            24 => Ok(Self::GpioGpio21),
            25 => Ok(Self::GpioGpio22),
            26 => Ok(Self::GpioGpio23),
            27 => Ok(Self::GpioGpio24),
            28 => Ok(Self::GpioGpio25),
            29 => Ok(Self::GpioGpio26),
            30 => Ok(Self::GpioGpio27),
            31 => Ok(Self::GpioGpio28),
            32 => Ok(Self::GpioGpio29),
            33 => Ok(Self::GpioGpio30),
            34 => Ok(Self::GpioGpio31),
            _ => Err(val),
        }
    }
}

/// Dedicated Pad Selects
#[repr(u32)]
pub enum TopDarjeelingDirectPads {
}

impl TryFrom<u32> for TopDarjeelingDirectPads {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            _ => Err(val),
        }
    }
}

/// Muxed Pad Selects
#[repr(u32)]
pub enum TopDarjeelingMuxedPads {
    DdrPcamp = 0,
}

impl TryFrom<u32> for TopDarjeelingMuxedPads {
    type Error = u32;
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0 => Ok(Self::DdrPcamp),
            _ => Err(val),
        }
    }
}

/// Power Manager Wakeup Signals
#[repr(u32)]
pub enum TopDarjeelingPowerManagerWakeUps {
    PinmuxAonPinWkupReq = 0,
    PinmuxAonUsbWkupReq = 1,
    AonTimerAonWkupReq = 2,
}

/// Reset Manager Software Controlled Resets
#[repr(u32)]
pub enum TopDarjeelingResetManagerSwResets {
    SpiDevice = 0,
    SpiHost0 = 1,
    SpiHost1 = 2,
    Usb = 3,
    UsbAon = 4,
    I2c0 = 5,
    I2c1 = 6,
    I2c2 = 7,
}

/// Power Manager Reset Request Signals
#[repr(u32)]
pub enum TopDarjeelingPowerManagerResetRequests {
    AonTimerAonAonTimerRstReq = 0,
}

/// Clock Manager Software-Controlled ("Gated") Clocks.
///
/// The Software has full control over these clocks.
#[repr(u32)]
pub enum TopDarjeelingGateableClocks {
    /// Clock clk_io_div4_peri in group peri
    IoDiv4Peri = 0,
    /// Clock clk_usb_peri in group peri
    UsbPeri = 1,
    /// Clock clk_io_peri in group peri
    IoPeri = 2,
}

/// Clock Manager Software-Hinted Clocks.
///
/// The Software has partial control over these clocks. It can ask them to stop,
/// but the clock manager is in control of whether the clock actually is stopped.
#[repr(u32)]
pub enum TopDarjeelingHintableClocks {
    /// Clock clk_main_otbn in group trans
    MainOtbn = 0,
}

/// MMIO Region
///
/// MMIO region excludes any memory that is separate from the module
/// configuration space, i.e. ROM, main SRAM, and flash are excluded but
/// retention SRAM, spi_device memory, or usbdev memory are included.
pub const TOP_DARJEELING_MMIO_BASE_ADDR: usize = 0x21130000;
pub const TOP_DARJEELING_MMIO_SIZE_BYTES: usize = 0xF3D0020;
